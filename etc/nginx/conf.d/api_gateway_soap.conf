# Finds invalid
# ~* Case-insensitive matching
map $request_body $is_invalid {
    default 0;
    "~*wsse:InvalidField" 1;
}


# Sets routing based on the "type: returned by auth server
# ~* Case-insensitive matching
map $env $set_upstream {
    default unknown;
    "~*OT30" OT30;
    "~*OT31" OT31;
    "~*X" x;
    "unknown" unknown;
    "error" error;
}

# Lastely, if the request is invalid the we respond with an error
# message, otherwise proxy to correct upstream
map $is_invalid $upstream {
    default $set_upstream;
    "1" error;
}

# Import the NJS used to validate request and make subrequest to auth server
js_import conf.d/authrouter.js;

# # Set variables extracted by our NJS functions
js_set $username authrouter.get_username;
js_set $password authrouter.get_password;
js_set $invalid authrouter.get_invalid;


# js_import conf.d/invalid_check.js;
# XML SOAP Gateway
server {

    # For test purposes we will use port 80
    listen 80 default_server;
    server_name www.example.com example.com "";
    status_zone www.example.com_http;

    # Error responses
    # error_page 404 = @501; # Invalid paths are treated as bad requests
    proxy_intercept_errors on; # Do not send backend errors to the client
    include /etc/nginx/api_soap_errors.conf; # API client friendly JSON error responses


    # text/xml is the SOAP 1.1 content type and application/soap+xml is the content type for SOAP 1.2.
    default_type text/xml;

    # Dedicated logs
    # access_log /var/log/nginx/www.example.com.log main_ext; # access logs
    # error_log  /var/log/nginx/www.example.com_errors.log info; # error logs

    location / {

        mirror /dummy_mirror ; # Since the default behavior is to simply stream the request body to the upstream without making a copy of it, we need to mirror the request to force the population of $request_body


        # # We are using auth_request to then do the NJS sub request
        auth_request /get_type_trampoline;

        # # Sets the request variable to the given value after the subrequest
        # # completes. The $env varible is set from the extracted "type" value
        # # from the auth server. The type value is returned from the auth_request
        # # as a "type " header
        auth_request_set $env $sent_http_type;

        # # include includes/proxy_headers/proxy_headers.conf;
        # # include includes/proxy_headers/keepalive.conf;

        # # We map $env to a $upstream, then proxy_pass to $upstream
        proxy_pass http://$upstream;

    }

    location = dummy_mirror {
        access_log off;
        return 204;

    }

    # This is a workaround location to get around an NGINX limitation
    # which disallows to create a subrequest from a subrequest
    # (auth_request is a subrequest, and the subrequest in js_content will fail),
    # instead we do a proxy_pass connection back to auxillary server
    location = /get_type_trampoline {
        internal; # Internal request only

        # Here we to a subrequest to a localhost location where NJS does a
        # Subrequest to the auth server
        proxy_pass http://127.0.0.1:8001/get_type;

        # Just send headers no body
        # proxy_pass_request_body on;
        proxy_set_header Content-Length "";
    }

    # Active Healthcheck
    # location @health_check {
    #     proxy_set_header Host www.example.com;
    #     proxy_pass http://authrouter;

    #     health_check interval=5s fails=2 passes=2 uri=/health match=status_json_ok;
    #     access_log /var/log/nginx/health_check.log main;
    #     internal; # Internal request only
    # }
}

# A localhost server where NJS does a sub request to the auth server
server {
    listen 8001;
    location = /get_type {
        # allow 127.0.0.1;

        # We run the NJS code here, that does a sub request to /env_endpoint
        js_content authrouter.get_type;
    }

    location = /env_endpoint {
        internal;
        proxy_pass http://authrouter;

    }
}