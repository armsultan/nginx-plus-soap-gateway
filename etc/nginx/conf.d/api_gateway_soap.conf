#
# Map Blocks to validate request and extract feilds
#
# ~* = Case-insensitive matching
# ~ =  Case-sensitive matching

# Check for invalid field in the security header
map $request_body $invalid {
    "~*<\/wsse:InvalidField>" 1;
    default 0;
}

# Extract <wsse:Username>
map $request_body $username {
    "~*<wsse:Username>(?<u>.*)<\/wsse:Username>" $u;
    default 0;
}

# Extract <wsse:Password>
map $request_body $password {
    "~*<wsse:Password>(?<p>.*)<\/wsse:Username>" $p;
    default 0;
}

# Sets routing based on type returned by auth server
# Case-insensitive matching
map $env $upstream {
    default             x;
    "~*OT30"            OT30;
    "~*OT31"            OT31;
    "~*X"               x;

}

# SOAP Gateway
    server {

        # For test purposes we will use port 80
        listen 80 default_server;
        server_name www.example.com example.com "";
        status_zone www.example.com_http;

        # Error responses
        error_page 404 = @501; # Invalid paths are treated as bad requests
        proxy_intercept_errors on; # Do not send backend errors to the client
        include /etc/nginx/api_soap_errors.conf; # API client friendly JSON error responses


        # text/xml is the SOAP 1.1 content type and application/soap+xml is the content type for SOAP 1.2.
        default_type text/xml;

        # Dedicated logs
        # access_log /var/log/nginx/www.example.com.log main_ext; # access logs
        # error_log  /var/log/nginx/www.example.com_errors.log info; # error logs

        location / {
            auth_request /get_type_trampoline;
            
            # sets the request variable to the given value after the subrequest 
            # completes. The value is set from the return value of the NJS
            # subrequest call inside of a auth_request call
            auth_request_set $env $sent_http_type;

            # include includes/proxy_headers/proxy_headers.conf;
            # include includes/proxy_headers/keepalive.conf;

            if ($invalid = "1") {
                return 502;
            }

            # use $env determines $upstream
            proxy_pass http://$upstream;

        }

        # this is a workaround location, to get around an nginx limitation
        # which disallows to create a subrequest from a subrequest
        # (auth_request is a subrequest, and the subrequest in js_content will fail),
        # instead we do a proxy_pass connection back to auxillary server
        location = /get_type_trampoline {
            internal; # Internal request only

            proxy_pass http://127.0.0.1:8001/get_type;

            # Just send headers no body
            proxy_pass_request_body off;
            proxy_set_header Content-Length "";
        }

        # Active Healthcheck
        location @health_check {
            proxy_set_header Host www.example.com;
            proxy_pass http://authrouter;

            health_check interval=5s fails=2 passes=2 uri=/health match=status_json_ok;
            access_log /var/log/nginx/health_check.log main;

            internal; # Internal request only
        }

    }

    # Localhost loopback that executes NJS subrequest to get environment variable
    js_import conf.d/authrouter.js;
    server {
        listen 8001;
        location = /get_type {
            # allow 127.0.0.1;

            # We run the NJS code here, that does a sub request to /env_endpoint
            js_content authrouter.get_type;
        }

        location = /env_endpoint {
            # internal;

            # We send a JSON body with "username":"$username" and 
            # "password":"$password", extracted from the client SOAP request
            proxy_set_body '{"created":"2020-08-12T17:46:35.942Z","nonce":"1","origin":"localhost","password":"$password","requestedMethod":"","requestedUri":"","username":"$username"}';
            proxy_pass_request_body on;

                proxy_pass http://authrouter;

            }
        }