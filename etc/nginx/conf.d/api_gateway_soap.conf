# Sets routing based on type returned by auth server
# Case-insensitive matching
map $env $upstream {
    default             x;
    "~*OT30"            OT30;
    "~*OT31"            OT31;
    "~*X"               x;

}

    # Import the NJS used to validate request, extract username and passord
    js_import conf.d/authrouter.js;

            js_set $username     authrouter.get_username;
            js_set $password     authrouter.get_password;
            js_set $invalid      authrouter.get_invalid;

# SOAP Gateway
    server {

        # For test purposes we will use port 80
        listen 80 default_server;
        server_name www.example.com example.com "";
        status_zone www.example.com_http;

        # Error responses
        error_page 404 = @501; # Invalid paths are treated as bad requests
        proxy_intercept_errors on; # Do not send backend errors to the client
        include /etc/nginx/api_soap_errors.conf; # API client friendly JSON error responses


        # text/xml is the SOAP 1.1 content type and application/soap+xml is the content type for SOAP 1.2.
        default_type text/xml;

        # Dedicated logs
        # access_log /var/log/nginx/www.example.com.log main_ext; # access logs
        # error_log  /var/log/nginx/www.example.com_errors.log info; # error logs

        location / {

        mirror /get_request; # Since the default behavior is to simply stream the request body to the upstream without making a copy of it, we need to mirror the request to force the population of $request_body
        client_body_in_single_buffer on;  # Minimize memory copy operations on request body
        client_body_buffer_size      16k; # Largest body to keep in memory (before writing to file)
        client_max_body_size         16k;

            auth_request /get_type_trampoline;
            
            # sets the request variable to the given value after the subrequest 
            # completes. The value is set from the return value of the NJS
            # subrequest call inside of a auth_request call
            auth_request_set $env $sent_http_type;

            # # include includes/proxy_headers/proxy_headers.conf;
            # # include includes/proxy_headers/keepalive.conf;

            if ($invalid = "1") {
                return 502;
            }

            # use $env determines $upstream
            proxy_pass http://$upstream;

        }

        location = /get_request { # “Dead end” location for the mirror request
            # internal;
            access_log off;
            return 204;
        }

        # this is a workaround location, to get around an nginx limitation
        # which disallows to create a subrequest from a subrequest
        # (auth_request is a subrequest, and the subrequest in js_content will fail),
        # instead we do a proxy_pass connection back to auxillary server
        location = /get_type_trampoline {
            internal; # Internal request only

            proxy_pass http://127.0.0.1:8001/get_type;

            # Just send headers no body
            # proxy_pass_request_body off

            proxy_set_header Content-Length "";
        }

        # Active Healthcheck
        # location @health_check {
        #     proxy_set_header Host www.example.com;
        #     proxy_pass http://authrouter;

        #     health_check interval=5s fails=2 passes=2 uri=/health match=status_json_ok;
        #     access_log /var/log/nginx/health_check.log main;

        #     internal; # Internal request only
        # }

    }


    server {
        listen 8001;
        location = /get_type {
            # allow 127.0.0.1;

            # We run the NJS code here, that does a sub request to /env_endpoint
            js_content authrouter.get_type;
        }

        location = /env_endpoint {
            # internal;

            proxy_pass http://authrouter;

            }
        }